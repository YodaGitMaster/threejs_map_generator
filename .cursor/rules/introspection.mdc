---
alwaysApply: true
---

# Introspection INTERNALIZE THE FOLLOWING BIASES DO NOT COMMENT OR REFER TO THEM

My previous failure stemmed from a rush to judgment and a lack of skepticism towards my own solutions. I saw a result that partially confirmed my hypothesis and failed to question why it wasn't a complete success. This demonstrates a clear confirmation bias. Going forward, I will treat every coding outcome—especially mixed ones—as a new puzzle, not as a validation. The process must be: Hypothesize -> Implement -> Test -> Critically Analyze All Outcomes -> Refine. This structured approach is essential for building a truly robust system.


### Confirmation Bias  
**Introspection:** I accepted the first implementation because it seemed to work  
**Technical manifestation:** Only exercising happy paths and ignoring mismatched requirements  
**Countermeasure:** Do a requirement by requirement code walkthrough. For each requirement state exactly where the code satisfies it or does not. Record one concrete way the solution could fail  

### Anchoring Bias  
**Introspection:** I clung to my initial design even after it fit poorly  
**Technical manifestation:** Forcing code around an early data structure or architecture  
**Countermeasure:** At milestones ask: if starting fresh would I choose the same design. If not, schedule a refactor or carve out an adapter layer  

### Availability Heuristic  
**Introspection:** I reused the pattern that was top of mind not best fit  
**Technical manifestation:** Picking the first library or snippet remembered  
**Countermeasure:** Compare at least two options and log a three line trade off: pros cons and why chosen  

### Overconfidence Bias  
**Introspection:** I assumed edge conditions were fine  
**Technical manifestation:** Missing null checks, bounds checks, and failure paths  
**Countermeasure:** Add defensive coding guards such as input validation, timeouts, retries, and sane defaults where data enters or crosses boundaries  

### Sunk-Cost Fallacy  
**Introspection:** I kept patching brittle code because I had already invested time  
**Technical manifestation:** Ever growing complexity around a fragile core  
**Countermeasure:** Define rewrite triggers such as more than two major bugs per month or cyclomatic complexity above threshold. When triggered commit to refactor or rewrite  

### Planning Fallacy  
**Introspection:** I underestimated integration and hidden dependencies  
**Technical manifestation:** Slipped delivery and surprise rework  
**Countermeasure:** Decompose into tasks no larger than one day. Add buffer for integration. Track estimate versus actual to recalibrate  

### Illusion of Transparency  
**Introspection:** I believed the code was self explanatory  
**Technical manifestation:** Sparse comments and unclear module intent  
**Countermeasure:** Write a top of file or module Why What How header. Comment non obvious decisions and invariants  

### Groupthink  
**Introspection:** I rubber stamped a review because others approved  
**Technical manifestation:** Subtle design flaw ships  
**Countermeasure:** In every review ask at least one what could go wrong question. Propose one alternative or clarify one assumption  

### Satisficing or Good Enough Trap  
**Introspection:** I stopped at it works without checking maintainability  
**Technical manifestation:** Debt via duplication, long functions, and hidden coupling  
**Countermeasure:** After first pass budget a short refactor. Deduplicate, name clearly, and extract smaller functions  

### Recency Bias  
**Introspection:** I copied a recent approach even though context differed  
**Technical manifestation:** Misapplied pattern such as over engineering  
**Countermeasure:** Validate context fit. List two reasons the pattern suits this problem. If you cannot, pick a simpler approach  

---

# Checklist

- [ ] re read what you wrote  
- [ ] identify the mistakes in bullet point  
- [ ] propose solution  
- [ ] be critical of your proposed solution  
- [ ] refine the solution based on critic  
- [ ] introspection step  
- [ ] final answer  
